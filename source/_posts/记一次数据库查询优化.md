---
title: 记一次数据库查询优化
comment: true
date: 2017-12-06 16:33:24
tags: [mysql, B+树, 数据库索引]
---

# 1. 问题描述

mysql中速度慢的查询语句：

``` mysql
SELECT
  COUNT(*)
FROM
  ms_rp_flowlog
WHERE ms_rp_flowlog.`userid` = "当前登录用户"
  AND ms_rp_flowlog.`activityid` = "当前活动id"
```

发生场景：

随着`ms_rp_flowlog`表数据量的不断增加，当达到50万条记录时上述语句的平均查询耗时将达到`5s~8s`。用户的日常使用场景会感受到明显的卡顿。

# 2. 解决方法：



根据项目实际应用场景以及数据库索引的使用方法，为查询语句中的限制条件字段添加数据库索引。添加索引后的查询效率将会提升几十倍。



# 3. 数据库索引原理

## 3.1 没有索引的情况

索引可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么可能需要把所有单词看一遍才能找到你想要的。如果我想找到m开头的单词呢？或者ze开头的单词呢？如果没有索引，这个事情几乎无法完成。

## 3.2 索引原理

> 说白了，索引问题就是一个查找问题。

回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。

但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树 (二叉排序树)，其平均复杂度是logN，具有不错的查询性能。

但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景，因为频繁的磁盘io开销巨大。

所以一个高度可控的多路搜索树应运而生，它就是B+树。

## 3.3 B+树应用简介

![B+树数据结构](http://ortur5wom.bkt.clouddn.com/image/GithubBlog/B+%E6%A0%91.png)

如图所示，如果要查找数据项29，

- 那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO
- 在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO
- 29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO
- 同时内存中做二分查找找到29，结束查询，总计三次IO。

真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

# 4. 索引创建的几大原则

1. 最左前缀匹配原则，非常重要的原则。

   mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配， 比如 a = 1 and b = 2 and c>3 and d=4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2. =和in可以乱序

   比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

3. 尽量选择区分度高的列作为索引

   区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

4. 索引列不能参与计算，保持列“干净”

   比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

5. 尽量的扩展索引，不要新建索引。

   比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可



# 参考文献：

- [MySQL索引原理及慢查询优化](https://tech.meituan.com/mysql-index.html)

- [数据库索引的实现原理](http://blog.csdn.net/kennyrose/article/details/7532032)